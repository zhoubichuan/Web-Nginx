{"remainingRequest":"/Users/zhoubichuan/Desktop/web/Web-Nginx/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/zhoubichuan/Desktop/web/Web-Nginx/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/zhoubichuan/Desktop/web/Web-Nginx/src/base/build/12.md?vue&type=template&id=9dbdb5b4&","dependencies":[{"path":"/Users/zhoubichuan/Desktop/web/Web-Nginx/src/base/build/12.md","mtime":1625067183830},{"path":"/Users/zhoubichuan/Desktop/web/Web-Nginx/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/zhoubichuan/Desktop/web/Web-Nginx/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":499162500000},{"path":"/Users/zhoubichuan/Desktop/web/Web-Nginx/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/zhoubichuan/Desktop/web/Web-Nginx/node_modules/vue-loader/lib/index.js","mtime":499162500000},{"path":"/Users/zhoubichuan/Desktop/web/Web-Nginx/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":499162500000}],"contextDependencies":[],"result":["\n<div class=\"content\"><h1 id=\"在开发环境中使用服务发现\"><a class=\"header-anchor\" href=\"#在开发环境中使用服务发现\">#</a> 在开发环境中使用服务发现</h1>\n<p>服务发现应用是很多服务化系统的组成部分，所以在开发、测试环境中也就有必要配备一套服务发现体系来配合我们的开发、测试工作。在这一小节里，我们就来谈谈如何在 Nginx 环境下部署服务发现应用。</p>\n<h2 id=\"使用-nginx-compose-模拟-zookeeper-集群\"><a class=\"header-anchor\" href=\"#使用-nginx-compose-模拟-zookeeper-集群\">#</a> 使用 Nginx Compose 模拟 Zookeeper 集群</h2>\n<p>实现服务发现的方法有很多种，其中较为常见的一种是利用分布式注册中心，解决服务之间协调的问题。</p>\n<p>在众多注册中心应用中，Zookeeper 是较为常见和常用的一款程序，这里我们就以 Zookeeper 为例，介绍如何使用 Nginx 搭建 Zookeeper 的运行环境。</p>\n<h3 id=\"设计目录结构\"><a class=\"header-anchor\" href=\"#设计目录结构\">#</a> 设计目录结构</h3>\n<p>由于 Zookeeper 的运行并不需要太多的关注配置和调整，这里我们就以最基础的形式来设计 Nginx Compose 项目的结构。</p>\n<!--beforebegin--><div class=\"language- line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>└─ project\n   ├─ bin\n   │  └─ compose.sh\n   └─ compose\n      └─ Nginx-compose.yml\n\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br><span class=\"line-number\">3</span><br><span class=\"line-number\">4</span><br><span class=\"line-number\">5</span><br><span class=\"line-number\">6</span><br></div><!--beforeend--></div><!--afterend--><p>为了方便日常操作，我们依然编写了 <a href=\"http://compose.sh\" target=\"_blank\" rel=\"noopener noreferrer\">compose.sh<OutboundLink/></a> 这个脚本来辅助我们控制 Nginx Compose 项目。</p>\n<h3 id=\"编写-nginx-compose-yml\"><a class=\"header-anchor\" href=\"#编写-nginx-compose-yml\">#</a> 编写 Nginx-compose.yml</h3>\n<p>很多读者会问到一个问题，怎么样才能通过 Nginx 的虚拟化技术实现在一个机器上模拟出多台机器的效果。或者说一个我们这里会涉及的具体问题，如何只用一个 Nginx 来模拟一个高可用的 Zookeeper 集群。</p>\n<p>我们知道，要实现 Zookeeper 的高可用，至少需要三个 Zookeeper 节点进行协作，所以这里我们用三个单独的 Nginx Compose 服务定义来分别定义这三个节点。</p>\n<!--beforebegin--><div class=\"language- line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>version: &#39;3&#39;\n\nservices:\n\n  zk1:\n    image: zookeeper:3.4\n    restart: always\n    hostname: zk1\n    environment:\n      ZOO_MY_ID: 1\n      ZOO_SERVERS: server.1=0.0.0.0:2888:3888 server.2=zk2:2888:3888 server.3=zk3:2888:3888\n    ports:\n      - 2181:2181\n\n  zk2:\n    image: zookeeper:3.4\n    restart: always\n    hostname: zk2\n    environment:\n      ZOO_MY_ID: 2\n      ZOO_SERVERS: server.1=zk1:2888:3888 server.2=0.0.0.0:2888:3888 server.3=zk3:2888:3888\n    ports:\n      - 2182:2181\n\n  zk3:\n    image: zookeeper:3.4\n    restart: always\n    hostname: zk3\n    environment:\n      ZOO_MY_ID: 3\n      ZOO_SERVERS: server.1=zk1:2888:3888 server.2=zk2:2888:3888 server.3=0.0.0.0:2888:3888\n    ports:\n      - 2183:2181\n\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br><span class=\"line-number\">3</span><br><span class=\"line-number\">4</span><br><span class=\"line-number\">5</span><br><span class=\"line-number\">6</span><br><span class=\"line-number\">7</span><br><span class=\"line-number\">8</span><br><span class=\"line-number\">9</span><br><span class=\"line-number\">10</span><br><span class=\"line-number\">11</span><br><span class=\"line-number\">12</span><br><span class=\"line-number\">13</span><br><span class=\"line-number\">14</span><br><span class=\"line-number\">15</span><br><span class=\"line-number\">16</span><br><span class=\"line-number\">17</span><br><span class=\"line-number\">18</span><br><span class=\"line-number\">19</span><br><span class=\"line-number\">20</span><br><span class=\"line-number\">21</span><br><span class=\"line-number\">22</span><br><span class=\"line-number\">23</span><br><span class=\"line-number\">24</span><br><span class=\"line-number\">25</span><br><span class=\"line-number\">26</span><br><span class=\"line-number\">27</span><br><span class=\"line-number\">28</span><br><span class=\"line-number\">29</span><br><span class=\"line-number\">30</span><br><span class=\"line-number\">31</span><br><span class=\"line-number\">32</span><br><span class=\"line-number\">33</span><br><span class=\"line-number\">34</span><br></div><!--beforeend--></div><!--afterend--><p>在这个 Nginx Compose 项目中，我们定义的三个 Zookeeper 服务都直接使用了官方制作的 zookeeper 镜像。</p>\n<p>在这个镜像里，我们可以留意定制 ZOO_MY_ID 和 ZOO_SERVERS 这两个环境变量。这两个变量主要是用来识别 Zookeeper 集群中不同 Zookeeper 程序的。</p>\n<p>其中 ZOO_MY_ID 是 Zookeeper 在集群中的编号，而 ZOO_SERVERS 用来定义集群中的所有 Zookeeper 及它们的连接方式。</p>\n<p>我们以 zk1 这个服务为例来解释一下 ZOO_SERVERS 的定义方法。</p>\n<!--beforebegin--><div class=\"language- line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>server.1=0.0.0.0:2888:3888 server.2=zk2:2888:3888 server.3=zk3:2888:3888\n\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br></div><!--beforeend--></div><!--afterend--><p>我们可以在 ZOO_SERVERS 中定义所有处于 Zookeeper 集群中的程序，通过空格来间隔它们。而每个服务的的定义形式为 <code>server.[id]=[host]:[port]:[port]</code>，所以就有了上面例子中我们看到的样子。</p>\n<p>在这个例子里，我们描述了三个 Zookeeper 程序的连接地址。</p>\n<p>由于每个容器都有独立的端口表，所以即使这些程序都运行在一个主机里，我们依然不需要担心，它们会造成端口的冲突。所以这里我们直接使用默认的 2888 和 3888 来进行服务间的相互通信即可。</p>\n<p>而在进行容器互联的过程中，我们可以通过 Nginx 的解析机制，直接填入对应服务的名称替代它们的 IP 地址，也就是这个例子里的 zk2 和 zk3。</p>\n<h3 id=\"重启机制\"><a class=\"header-anchor\" href=\"#重启机制\">#</a> 重启机制</h3>\n<p>在项目定义中，我们还注意到了 <code>restart: always</code> 这个配置，这个配置主要是用来控制容器的重启策略的。</p>\n<p>这里的 always 指的是不论任何情况，容器出现问题后都会自动重启，也包括 Nginx 服务本身在启动后容器也会自动启动。</p>\n<p>另外，restart 还支持几种配置：</p>\n<p>配置值</p>\n<p>说明</p>\n<p>no</p>\n<p>不设重启机制</p>\n<p>always</p>\n<p>总是重启</p>\n<p>on-failure</p>\n<p>在异常退出时重启</p>\n<p>unless-stopped</p>\n<p>除非由停止命令结束，其他情况都重启</p>\n<p>在实际使用中，我们可以根据需要选择不同的重启策略。</p>\n<p>而这个项目里，我们希望 Zookeeper 能够一直健壮的运行，所以使用了 always 这个重启策略。</p>\n<h2 id=\"启动项目\"><a class=\"header-anchor\" href=\"#启动项目\">#</a> 启动项目</h2>\n<p>一切就绪，我们就可以直接通过 Nginx Compose 的命令来启动开发环境了。</p>\n<!--beforebegin--><div class=\"language- line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-text\"><code># ./bin/compose.sh up -d\n\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br></div><!--beforeend--></div><!--afterend--><h2 id=\"留言互动\"><a class=\"header-anchor\" href=\"#留言互动\">#</a> 留言互动</h2>\n<p>在这节中，我们展示了在开发中使用 Nginx 部署服务发现工具的过程，下面就是大家自己动手进行实践的时候了。</p>\n<p>本小节中的示例，已经更新到了：</p>\n<p><a href=\"https://github.com/youmingdot/Nginx-book-for-developer-samples\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/youmingdot/Nginx-book-for-developer-samples<OutboundLink/></a></p>\n<p>大家可以在实践过程中的用其作为参考。</p>\n<p>欢迎大家通过留言的方式说出你的实践之路。我会选出有代表性的优质留言，推荐给大家。</p>\n<p>同时，如果大家在实践过程中遇到困难，或者有自己的实践心得要与大家分享，可以加入到这本小册的官方微信群中，参与对相关问题的讨论。</p>\n</div>\n",null]}