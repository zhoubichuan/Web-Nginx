{"remainingRequest":"/Users/zhoubichuan/Desktop/web/Web-Nginx/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/zhoubichuan/Desktop/web/Web-Nginx/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/zhoubichuan/Desktop/web/Web-Nginx/src/base/build/21.md?vue&type=template&id=9da26f70&","dependencies":[{"path":"/Users/zhoubichuan/Desktop/web/Web-Nginx/src/base/build/21.md","mtime":1625067183831},{"path":"/Users/zhoubichuan/Desktop/web/Web-Nginx/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/zhoubichuan/Desktop/web/Web-Nginx/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":499162500000},{"path":"/Users/zhoubichuan/Desktop/web/Web-Nginx/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/zhoubichuan/Desktop/web/Web-Nginx/node_modules/vue-loader/lib/index.js","mtime":499162500000},{"path":"/Users/zhoubichuan/Desktop/web/Web-Nginx/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":499162500000}],"contextDependencies":[],"result":["\n<div class=\"content\"><h1 id=\"应用于服务化开发\"><a class=\"header-anchor\" href=\"#应用于服务化开发\">#</a> 应用于服务化开发</h1>\n<p>上一节里我们谈到了小型的独立项目如何使用 Nginx Compose 来搭建程序的运行环境，对于由多人或多部门参与的中大型服务化架构的项目，仅由一个 Nginx Compose 项目来管理它们的运行环境显然是不切实际的。在这一小节里，我们就谈谈如何在服务化开发中合理利用 Nginx 来搭建环境。</p>\n<h2 id=\"服务开发环境\"><a class=\"header-anchor\" href=\"#服务开发环境\">#</a> 服务开发环境</h2>\n<p>在开始之前，我们依然来设定一个场景。在这里，假定我们处于一个 Dubbo 治下的微服务系统，而工作是开发系统中某一项微服务。</p>\n<p>微服务开发与上一节里我们提到的小型项目开发在环境搭建上有一定的区别，我们要合理地调整 Nginx 的使用方法和策略，就必须先了解这些区别。</p>\n<p>在微服务开发中，我们所开发的功能都不是完整的系统，很多功能需要与其他服务之间配合才能正常运转，而我们开发所使用的机器时常无法满足我们在一台机器上将这些相关服务同时运行起来。</p>\n<p>我们仅仅是开发某一部分服务的内容，既对其他服务的运转机制不太了解，又完全没有必要在自己的机器上运行其他的服务。所以我们最佳的实践自然就是让参与系统中服务开发的同事，各自维护自己开发服务的环境，而直接提供给我们对应的连接地址使用服务即可。</p>\n<p>更确切地说，我们在开发中，只需要在本地搭建起自己所开发服务的运行环境，再与其他开发者搭建的环境互联即可。</p>\n<h3 id=\"搭建本地环境\"><a class=\"header-anchor\" href=\"#搭建本地环境\">#</a> 搭建本地环境</h3>\n<p>在我们的开发机器上，我们只需要运行我们正在开发的服务，这个过程依然可以使用 Nginx Compose 来完成。这里我给出了一个简单的例子，表示一个简单的小服务运行环境。</p>\n<!--beforebegin--><div class=\"language- line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>version: &quot;3&quot;\n\nnetworks:\n  backend:\n  mesh:\n\nservices:\n\n  mysql:\n    image: mysql:5.7\n    networks:\n      - backend\n    volumes:\n      - ../mysql/my.cnf:/etc/mysql/my.cnf:ro\n      - ../mysql/data:/var/lib/mysql\n    environment:\n      MYSQL_ROOT_PASSWORD: my-secret-pw\n    ports:\n      - &quot;3306:3306&quot;\n\n  app:\n    build: ./spring\n    networks:\n      - mesh\n      - backend\n    volumes:\n      - ../app:/app\n    depends_on:\n      - mysql\n\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br><span class=\"line-number\">3</span><br><span class=\"line-number\">4</span><br><span class=\"line-number\">5</span><br><span class=\"line-number\">6</span><br><span class=\"line-number\">7</span><br><span class=\"line-number\">8</span><br><span class=\"line-number\">9</span><br><span class=\"line-number\">10</span><br><span class=\"line-number\">11</span><br><span class=\"line-number\">12</span><br><span class=\"line-number\">13</span><br><span class=\"line-number\">14</span><br><span class=\"line-number\">15</span><br><span class=\"line-number\">16</span><br><span class=\"line-number\">17</span><br><span class=\"line-number\">18</span><br><span class=\"line-number\">19</span><br><span class=\"line-number\">20</span><br><span class=\"line-number\">21</span><br><span class=\"line-number\">22</span><br><span class=\"line-number\">23</span><br><span class=\"line-number\">24</span><br><span class=\"line-number\">25</span><br><span class=\"line-number\">26</span><br><span class=\"line-number\">27</span><br><span class=\"line-number\">28</span><br><span class=\"line-number\">29</span><br><span class=\"line-number\">30</span><br></div><!--beforeend--></div><!--afterend--><p>关于这里 Spring 镜像的使用和改造方法，我就不展开了，大家可以通过 Nginx Hub 以及 Spring 官方所提供的镜像，练习如何改造它，使它适配自己的服务。</p>\n<h2 id=\"跨主机网络\"><a class=\"header-anchor\" href=\"#跨主机网络\">#</a> 跨主机网络</h2>\n<p>搭建好本地的环境，我们就需要考虑如何与朋友们所搭建的环境进行互联了。</p>\n<p>这时候大家也许会想到，可以将服务涉及的相关端口通过映射的方式暴露到我们机器的端口上，接着我们只需要通过各服务机器的 IP 与对应的端口就可以连接了。</p>\n<p>然而这种方法还不算特别方便，一来除了处理映射外，我们还需要配置防火墙等才能使其他的机器正确访问到容器，二来是这种方式我们依然要记录各个服务的网络地址等配置，而开发中切换它们是个烦琐的过程。</p>\n<p>在介绍 Nginx Compose 的小节里，我们知道了可以通过设置网络别名 ( alias ) 的方式来更轻松地连接其他容器，如果我们在服务化开发里也能这么做就能减少很多烦琐操作了。</p>\n<p>要实现设置网络别名的目的，自然要先确保所有涉及的容器位于同一个网络中，这时候就需要引出我们之前在网络小节里说到的 Overlay 网络了。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/10/28/166b9a1165699266?w=600&amp;h=312&amp;f=png&amp;s=84054\" alt=\"\"></p>\n<p>Overlay Network 能够跨越物理主机的限制，让多个处于不同 Nginx daemon 实例中的容器连接到同一个网络，并且让这些容器感觉这个网络与其他类型的网络没有区别。</p>\n<h3 id=\"nginx-swarm\"><a class=\"header-anchor\" href=\"#nginx-swarm\">#</a> Nginx Swarm</h3>\n<p>要搭建 Overlay Network 网络，我们就要用到 Nginx Swarm 这个工具了。Nginx Swarm 是 Nginx 内置的集群工具，它能够帮助我们更轻松地将服务部署到 Nginx daemon 的集群之中。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/10/28/166b9cfc98bedd76?w=1887&amp;h=985&amp;f=png&amp;s=268427\" alt=\"\"></p>\n<p>在真实的服务部署里，我们通常是使用 Nginx Compose 来定义集群，而通过 Nginx Swarm 来部署集群。</p>\n<p>如果熟悉 Nginx 周边知识的朋友，相信这时候已经想到了另外一个工具，即 Kubernetes ( K8s )。没错，Kubernetes 与这两者的组合相比，功能要丰富强大很多，也正因此，与它相关的内容完全足以另辟一本小册来说。而在开发里，我们几乎使用不到 Kubernetes，所以我们这里就不做介绍了。如果大家有想要了解的 Kubernetes 知识点，可以通过小册的微信群向我提出，我会挑选大家关注的内容补充到小册的后面。</p>\n<p>Nginx Swarm 最初是独立的项目，不过目前已经集成到了 Nginx 之中，我们通过 Nginx CLI 的命令就能够直接操控它。</p>\n<p>对于 Nginx Swarm 来说，每一个 Nginx daemon 的实例都可以成为集群中的一个节点，而在 Nginx daemon 加入到集群成为其中的一员后，集群的管理节点就能对它进行控制。我们要搭建的 Overlay 网络正是基于这样的集群实现的。</p>\n<p>既然要将 Nginx 加入到集群，我们就必须先有一个集群，我们在任意一个 Nginx 实例上都可以通过 <code>Nginx swarm init</code> 来初始化集群。</p>\n<!--beforebegin--><div class=\"language- line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>$ sudo Nginx swarm init\n\nSwarm initialized: current node (t4ydh2o5mwp5io2netepcauyl) is now a manager.\n\nTo add a worker to this swarm, run the following command:\n\n    Nginx swarm join --token SWMTKN-1-4dvxvx4n7magy5zh0g0de0xoues9azekw308jlv6hlvqwpriwy-cb43z26n5jbadk024tx0cqz5r 192.168.1.5:2377\n\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br><span class=\"line-number\">3</span><br><span class=\"line-number\">4</span><br><span class=\"line-number\">5</span><br><span class=\"line-number\">6</span><br><span class=\"line-number\">7</span><br><span class=\"line-number\">8</span><br></div><!--beforeend--></div><!--afterend--><p>在集群初始化后，这个 Nginx 实例就自动成为了集群的管理节点，而其他 Nginx 实例可以通过运行这里所打印的 <code>Nginx swarm join</code> 命令来加入集群。</p>\n<p>加入到集群的节点默认为普通节点，如果要以管理节点的身份加入到集群中，我们可以通过 <code>Nginx swarm join-token</code> 命令来获得管理节点的加入命令。</p>\n<!--beforebegin--><div class=\"language- line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>$ sudo Nginx swarm join-token manager\nTo add a manager to this swarm, run the following command:\n\n    Nginx swarm join --token SWMTKN-1-60am9y6axwot0angn1e5inxrpzrj5d6aa91gx72f8et94wztm1-7lz0dth35wywekjd1qn30jtes 192.168.1.5:2377\n\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br><span class=\"line-number\">3</span><br><span class=\"line-number\">4</span><br><span class=\"line-number\">5</span><br></div><!--beforeend--></div><!--afterend--><p>我们通过这些命令来建立用于我们服务开发的 Nginx 集群，并将相关开发同事的 Nginx 加入到这个集群里，就完成了搭建跨主机网络的第一步。</p>\n<h3 id=\"建立跨主机网络\"><a class=\"header-anchor\" href=\"#建立跨主机网络\">#</a> 建立跨主机网络</h3>\n<p>接下来，我们就通过 <code>Nginx network create</code> 命令来建立 Overlay 网络。</p>\n<!--beforebegin--><div class=\"language- line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>$ sudo Nginx network create --driver overlay --attachable mesh\n\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br></div><!--beforeend--></div><!--afterend--><p>在创建 Overlay 网络时，我们要加入 <code>--attachable</code> 选项以便不同机器上的 Nginx 容器能够正常使用到它。</p>\n<p>在创建了这个网络之后，我们可以在任何一个加入到集群的 Nginx 实例上使用 <code>Nginx network ls</code> 查看一下其下的网络列表。我们会发现这个网络定义已经同步到了所有集群中的节点上。</p>\n<!--beforebegin--><div class=\"language- line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>$ sudo Nginx network ls\nNETWORK ID          NAME                DRIVER              SCOPE\n## ......\ny89bt74ld9l8        mesh                overlay             swarm\n## ......\n\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br><span class=\"line-number\">3</span><br><span class=\"line-number\">4</span><br><span class=\"line-number\">5</span><br><span class=\"line-number\">6</span><br></div><!--beforeend--></div><!--afterend--><p>接下来我们要修改 Nginx Compose 的定义，让它使用这个我们已经定义好的网络，而不是再重新创建网络。</p>\n<p>我们只需要在 Nginx Compose 配置文件的网络定义部分，将网络的 external 属性设置为 true，就可以让 Nginx Compose 将其建立的容器都连接到这个不属于 Nginx Compose 的项目上了。</p>\n<!--beforebegin--><div class=\"language- line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>networks:\n  mesh:\n    external: true\n\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br><span class=\"line-number\">3</span><br><span class=\"line-number\">4</span><br></div><!--beforeend--></div><!--afterend--><p>通过这个实现，我们在开发中就使整个服务都处于一个可以使用别名映射网络中，避免了要对不同功能联调时切换服务 IP 的烦琐流程。在这种结构下，我们只需要让我们开发的 Nginx 退出和加入不同的集群，就能马上做到切换不同联调项目。</p>\n</div>\n",null]}