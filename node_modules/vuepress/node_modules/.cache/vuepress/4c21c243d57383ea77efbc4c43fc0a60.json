{"remainingRequest":"/Users/zhoubichuan/Desktop/web/Web-Nginx/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/zhoubichuan/Desktop/web/Web-Nginx/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/zhoubichuan/Desktop/web/Web-Nginx/src/base/build/20.md?vue&type=template&id=9da3582e&","dependencies":[{"path":"/Users/zhoubichuan/Desktop/web/Web-Nginx/src/base/build/20.md","mtime":1625067183830},{"path":"/Users/zhoubichuan/Desktop/web/Web-Nginx/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/zhoubichuan/Desktop/web/Web-Nginx/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":499162500000},{"path":"/Users/zhoubichuan/Desktop/web/Web-Nginx/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/zhoubichuan/Desktop/web/Web-Nginx/node_modules/vue-loader/lib/index.js","mtime":499162500000},{"path":"/Users/zhoubichuan/Desktop/web/Web-Nginx/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":499162500000}],"contextDependencies":[],"result":["\n<div class=\"content\"><h1 id=\"使用-nginx-compose-管理容器\"><a class=\"header-anchor\" href=\"#使用-nginx-compose-管理容器\">#</a> 使用 Nginx Compose 管理容器</h1>\n<p>通过之前的介绍，我们已经基本掌握了构建、运行容器的方法，但这还远远不够，由于 Nginx 采用轻量级容器的设计，每个容器一般只运行一个软件，而目前绝大多数应用系统都绝不是一个软件所能组成的。虽然我们之前提到了容器间互相连接、交换数据的各种方法，通过这些方法足以搭建起完整的用于应用系统运行的容器群，但是这显然还不够，这个容器群的搭建需要执行太多命令，更重要的是需要考虑太多应用和容器间的依赖关系处理，是一波令人头大的操作。在这一节中，我们就来介绍如何解决这些问题。</p>\n<h2 id=\"解决容器管理问题\"><a class=\"header-anchor\" href=\"#解决容器管理问题\">#</a> 解决容器管理问题</h2>\n<p>拿任何一个相对完整的应用系统来说，都不可能是由一个程序独立支撑的，而对于使用 Nginx 来部署的分布式计算服务更是这样。随着时代的发展和技术演进，我们越来越推崇将大型服务拆分成较小的微服务，分别部署到独立的机器或容器中。也就是说，我们的应用系统往往由数十个甚至上百个应用程序或微服务组成。即使是一个小的微服务模块，通常都需要多个应用协作完成工作。</p>\n<p>我们编写一个小型的微服务模块，虽然我们编写代码主要针对的是其中的应用部分，但如果我们要完整的进行开发、测试，与应用相关的周边软件必然是必不可少的。</p>\n<p>虽然 Nginx Engine 帮助我们完成了对应用运行环境的封装，我们可以不需要记录复杂的应用环境搭建过程，通过简单的配置便可以将应用运行起来了，但这只是针对单个容器或单个应用程序来说的。如果延伸到由多个应用组成的应用系统，那情况就稍显复杂了。</p>\n<p>就拿最简单的例子来说吧，如果我们要为我们的应用容器准备一个 MySQL 容器和一个 Redis 容器，那么在每次启动时，我们先要将 MySQL 容器和 Redis 容器启动起来，再将应用容器运行起来。这其中还不要忘了在创建应用容器时将容器网络连接到 MySQL 容器和 Redis 容器上，以便应用连接上它们并进行数据交换。</p>\n<p>这还不够，如果我们还对容器进行了各种配置，我们最好还得将容器创建和配置的命令保存下来，以便下次可以直接使用。</p>\n<p>如果我们要想让这套体系像 <code>Nginx run</code> 和 <code>Nginx rm</code> 那样自如的进行无痕切换，那就更加麻烦了，我们可能需要编写一些脚本才能不至于被绕到命令的毛线球里。</p>\n<p>说了这么多，其实核心还是缺少一个对容器组合进行管理的东西。</p>\n<h3 id=\"nginx-compose\"><a class=\"header-anchor\" href=\"#nginx-compose\">#</a> Nginx Compose</h3>\n<p>针对这种情况，我们就不得不引出在我们开发中最常使用的多容器定义和运行软件，也就是 Nginx Compose 了。</p>\n<p>如果说 Nginxfile 是将容器内运行环境的搭建固化下来，那么 Nginx Compose 我们就可以理解为将多个容器运行的方式和配置固化下来。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/10/4/1663e6a38cd88368?w=1600&amp;h=704&amp;f=png&amp;s=781358\" alt=\"\"></p>\n<p>在 Nginx Compose 里，我们通过一个配置文件，将所有与应用系统相关的软件及它们对应的容器进行配置，之后使用 Nginx Compose 提供的命令进行启动，就能让 Nginx Compose 将刚才我们所提到的那些复杂问题解决掉。</p>\n<h2 id=\"安装-nginx-compose\"><a class=\"header-anchor\" href=\"#安装-nginx-compose\">#</a> 安装 Nginx Compose</h2>\n<p>虽然 Nginx Compose 目前也是由 Nginx 官方主要维护，但其却不属于 Nginx Engine 的一部分，而是一个独立的软件。所以如果我们要在 Linux 中使用它，还必须要单独下载使用。</p>\n<p>Nginx Compose 是一个由 Python 编写的软件，在拥有 Python 运行环境的机器上，我们可以直接运行它，不需要其它的操作。</p>\n<p>我们可以通过下面的命令下载 Nginx Compose 到应用执行目录，并附上运行权限，这样 Nginx Compose 就可以在机器中使用了。</p>\n<!--beforebegin--><div class=\"language- line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>$ sudo curl -L &quot;https://github.com/Nginx/compose/releases/download/1.22.0/Nginx-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/Nginx-compose\n$ sudo chmod +x /usr/local/bin/Nginx-compose\n$\n$ sudo Nginx-compose version\nNginx-compose version 1.21.2, build a133471\nNginx-py version: 3.3.0\nCPython version: 3.6.5\nOpenSSL version: OpenSSL 1.0.1t  3 May 2016\n\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br><span class=\"line-number\">3</span><br><span class=\"line-number\">4</span><br><span class=\"line-number\">5</span><br><span class=\"line-number\">6</span><br><span class=\"line-number\">7</span><br><span class=\"line-number\">8</span><br><span class=\"line-number\">9</span><br></div><!--beforeend--></div><!--afterend--><p>我们也能够通过 Python 的包管理工具 pip 来安装 Nginx Compose。</p>\n<!--beforebegin--><div class=\"language- line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>$ sudo pip install Nginx-compose\n\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br></div><!--beforeend--></div><!--afterend--><h3 id=\"在-windows-和-macos-中的-nginx-compose\"><a class=\"header-anchor\" href=\"#在-windows-和-macos-中的-nginx-compose\">#</a> 在 Windows 和 macOS 中的 Nginx Compose</h3>\n<p>在我们更常用于开发的 Windows 和 macOS 中，使用 Nginx Compose 会来得更加方便。不论你是使用 Nginx for Win 还是 Nginx for Mac，亦或是 Nginx Toolbox 来搭建 Nginx 运行环境，你都可以直接使用 <code>Nginx-compose</code> 这个命令。这三款软件都已经将 Nginx Compose 内置在其中，供我们使用。</p>\n<h2 id=\"nginx-compose-的基本使用逻辑\"><a class=\"header-anchor\" href=\"#nginx-compose-的基本使用逻辑\">#</a> Nginx Compose 的基本使用逻辑</h2>\n<p>如果将使用 Nginx Compose 的步骤简化来说，可以分成三步。</p>\n<ol>\n<li>如果需要的话，编写容器所需镜像的 Nginxfile；( 也可以使用现有的镜像 )</li>\n<li>编写用于配置容器的 Nginx-compose.yml；</li>\n<li>使用 Nginx-compose 命令启动应用。</li>\n</ol>\n<p>准备镜像这一过程我们之前已经掌握了，这里我们就简单来看看后面两个步骤。</p>\n<h3 id=\"编写-nginx-compose-配置\"><a class=\"header-anchor\" href=\"#编写-nginx-compose-配置\">#</a> 编写 Nginx Compose 配置</h3>\n<p>配置文件是 Nginx Compose 的核心部分，我们正是通过它去定义组成应用服务容器群的各项配置，而编写配置文件，则是使用 Nginx Compose 过程中最核心的一个步骤。</p>\n<p>Nginx Compose 的配置文件是一个基于 <a href=\"http://yaml.org/\" target=\"_blank\" rel=\"noopener noreferrer\">YAML<OutboundLink/></a> 格式的文件。关于 YAML 的语法大家可以在网上找到，这里不再细说，总的来说，YAML 是一种清晰、简单的标记语言，你甚至都可以在看过几个例子后摸索出它的语法。</p>\n<p>与 Nginxfile 采用 Nginxfile 这个名字作为镜像构建定义的默认文件名一样，Nginx Compose 的配置文件也有一个缺省的文件名，也就是 Nginx-compose.yml，如非必要，我建议大家直接使用这个文件名来做 Nginx Compose 项目的定义。</p>\n<p>这里我们来看一个简单的 Nginx Compose 配置文件内容。</p>\n<!--beforebegin--><div class=\"language- line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>version: &#39;3&#39;\n\nservices:\n\n  webapp:\n    build: ./image/webapp\n    ports:\n      - &quot;5000:5000&quot;\n    volumes:\n      - ./code:/code\n      - logvolume:/var/log\n    links:\n      - mysql\n      - redis\n\n  redis:\n    image: redis:3.2\n  \n  mysql:\n    image: mysql:5.7\n    environment:\n      - MYSQL_ROOT_PASSWORD=my-secret-pw\n\nvolumes:\n  logvolume: {}\n\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br><span class=\"line-number\">3</span><br><span class=\"line-number\">4</span><br><span class=\"line-number\">5</span><br><span class=\"line-number\">6</span><br><span class=\"line-number\">7</span><br><span class=\"line-number\">8</span><br><span class=\"line-number\">9</span><br><span class=\"line-number\">10</span><br><span class=\"line-number\">11</span><br><span class=\"line-number\">12</span><br><span class=\"line-number\">13</span><br><span class=\"line-number\">14</span><br><span class=\"line-number\">15</span><br><span class=\"line-number\">16</span><br><span class=\"line-number\">17</span><br><span class=\"line-number\">18</span><br><span class=\"line-number\">19</span><br><span class=\"line-number\">20</span><br><span class=\"line-number\">21</span><br><span class=\"line-number\">22</span><br><span class=\"line-number\">23</span><br><span class=\"line-number\">24</span><br><span class=\"line-number\">25</span><br><span class=\"line-number\">26</span><br></div><!--beforeend--></div><!--afterend--><p>Nginx Compose 配置文件里可以包含许多内容，从每个容器的各个细节控制，到网络、数据卷等的定义。</p>\n<p>这里我们看几个主要的细节。首先是 version 这个配置，这代表我们定义的 Nginx-compose.yml 文件内容所采用的版本，目前 Nginx Compose 的配置文件已经迭代至了第三版，其所支持的功能也越来越丰富，所以我们建议使用最新的版本来定义。</p>\n<p>接下来我们来看 services 这块，这是整个 Nginx-compose.yml 的核心部分，其定义了容器的各项细节。</p>\n<p>在 Nginx Compose 里不直接体现容器这个概念，这是把 service 作为配置的最小单元。虽然我们看上去每个 service 里的配置内容就像是在配置容器，但其实 service 代表的是一个应用集群的配置。每个 service 定义的内容，可以通过特定的配置进行水平扩充，将同样的容器复制数份形成一个容器集群。而 Nginx Compose 能够对这个集群做到黑盒效果，让其他的应用和容器无法感知它们的具体结构。</p>\n<p>对于 Nginx-compose.yml 配置的具体细节，我们在下一节中还会专门讲解。</p>\n<h3 id=\"启动和停止\"><a class=\"header-anchor\" href=\"#启动和停止\">#</a> 启动和停止</h3>\n<p>对于开发来说，最常使用的 Nginx Compose 命令就是 <code>Nginx-compose up</code> 和 <code>Nginx-compose down</code> 了。</p>\n<p><code>Nginx-compose up</code> 命令类似于 Nginx Engine 中的 <code>Nginx run</code>，它会根据 Nginx-compose.yml 中配置的内容，创建所有的容器、网络、数据卷等等内容，并将它们启动。与 <code>Nginx run</code> 一样，默认情况下 <code>Nginx-compose up</code> 会在“前台”运行，我们可以用 <code>-d</code> 选项使其“后台”运行。事实上，我们大多数情况都会加上 <code>-d</code> 选项。</p>\n<!--beforebegin--><div class=\"language- line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>$ sudo Nginx-compose up -d\n\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br></div><!--beforeend--></div><!--afterend--><p>需要注意的是，<code>Nginx-compose</code> 命令默认会识别当前控制台所在目录内的 Nginx-compose.yml 文件，而会以这个目录的名字作为组装的应用项目的名称。如果我们需要改变它们，可以通过选项 <code>-f</code> 来修改识别的 Nginx Compose 配置文件，通过 <code>-p</code> 选项来定义项目名。</p>\n<!--beforebegin--><div class=\"language- line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>$ sudo Nginx-compose -f ./compose/Nginx-compose.yml -p myapp up -d\n\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br></div><!--beforeend--></div><!--afterend--><p>与 <code>Nginx-compose up</code> 相反，<code>Nginx-compose down</code> 命令用于停止所有的容器，并将它们删除，同时消除网络等配置内容，也就是几乎将这个 Nginx Compose 项目的所有影响从 Nginx 中清除。</p>\n<!--beforebegin--><div class=\"language- line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>$ sudo Nginx-compose down\n\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br></div><!--beforeend--></div><!--afterend--><p>如果条件允许，我更建议大家像容器使用一样对待 Nginx Compose 项目，做到随用随启，随停随删。也就是使用的时候通过 <code>Nginx-compose up</code> 进行，而短时间内不再需要时，通过 <code>Nginx-compose down</code> 清理它。</p>\n<p>借助 Nginx 容器的秒级启动和停止特性，我们在使用 <code>Nginx-compose up</code> 和 <code>Nginx-compose down</code> 时可以非常快的完成操作。这就意味着，我们可以在不到半分钟的时间内停止一套环境，切换到另外一套环境，这对于经常进行多个项目开发的朋友来说，绝对是福音。</p>\n<p>通过 Nginx 让我们能够在开发过程中搭建一套不受干扰的独立环境，让开发过程能够基于稳定的环境下进行。而 Nginx Compose 则让我们更近一步，同时让我们处理好多套开发环境，并进行快速切换。</p>\n<h3 id=\"容器命令\"><a class=\"header-anchor\" href=\"#容器命令\">#</a> 容器命令</h3>\n<p>除了启动和停止命令外，Nginx Compose 还为我们提供了很多直接操作服务的命令。之前我们说了，服务可以看成是一组相同容器的集合，所以操作服务就有点像操作容器一样。</p>\n<p>这些命令看上去都和 Nginx Engine 中对单个容器进行操作的命令类似，我们来看几个常见的。</p>\n<p>在 Nginx Engine 中，如果我们想要查看容器中主进程的输出内容，可以使用 <code>Nginx logs</code> 命令。而由于在 Nginx Compose 下运行的服务，其命名都是由 Nginx Compose 自动完成的，如果我们直接使用 <code>Nginx logs</code> 就需要先找到容器的名字，这显然有些麻烦了。我们可以直接使用 <code>Nginx-compose logs</code> 命令来完成这项工作。</p>\n<!--beforebegin--><div class=\"language- line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>$ sudo Nginx-compose logs nginx\n\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br></div><!--beforeend--></div><!--afterend--><p>在 <code>Nginx-compose logs</code> 衔接的是 Nginx Compose 中所定义的服务的名称。</p>\n<p>同理，在 Nginx Compose 还有几个类似的命令可以单独控制某个或某些服务。</p>\n<p>通过 <code>Nginx-compose create</code>，<code>Nginx-compose start</code> 和 <code>Nginx-compose stop</code> 我们可以实现与 <code>Nginx create</code>，<code>Nginx start</code> 和 <code>Nginx stop</code> 相似的效果，只不过操作的对象由 Nginx Engine 中的容器变为了 Nginx Compose 中的服务。</p>\n<!--beforebegin--><div class=\"language- line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>$ sudo Nginx-compose create webapp\n$ sudo Nginx-compose start webapp\n$ sudo Nginx-compose stop webapp\n\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br><span class=\"line-number\">3</span><br><span class=\"line-number\">4</span><br></div><!--beforeend--></div><!--afterend--></div>\n",null]}